package com.example.kotlinlanguage.part1

/**
 * 실수 값을 보관하는 법을 알아본다.
 */
fun main(args: Array<String>) {

    /**
     * 정수 타입
     * 타입 이름 - Byte, 단위 - 1Byte -> 매우 작은 수를 처리할 때 사용, 예를 들어 점수 같은 경우 (최대 점수 100점 인 경우) , 1바이트의 저장 범위는 -128 ~ 127
     * 타입 이름 - Short, 단위 - 2Byte
     * 타입 이름 - Int, 단위 - 4Byte -> 일반적인 경우라면 Int 타입만으로 커버가 가능하지만, 매우 큰 수를 다루는 프로그램을 다루는 경우 저장 가능 범위를 초과할 수 도 있다.
     * 타입 이름 - Long, 단위 - 8Byte -> 그럴 경우 Long 타입을 사용하는데, 만약 Long 타입의 범위까지 초과하는 경우는 어떻게 할까?
     *
     * 실수 타입 (실수에 있어서 저장 가능 범위보다 소수점을 어디까지 표현할 수 있는지가 더 중요!)
     *
     * 타입 이름 - Float, 단위 - 4Byte
     * 타입 이름 - Double, 단위 - 8Byte -> Double 타입은 Float 타입 보다 2배 정밀하다고 해서 Double이라는 이름으로 붙여짐.
     *
     */

    val a: Byte = 125 //리터럴 125는 Int 타입이여서 Byte 타입의 변수로 저장할 수 없지만 표현식이 리터럴로만 이루여져 있고 그 값이 Byte 타입 저장 가능 범위 안에 있을 경우에 한해서는 저장이 허용
    val b: Short = ( 100 + 200 ) * 100 // 해당 케이스도 마찬가지이며 소괄호로 둘러싼 부분은 연산자의 우선순위와 상관없이 제일 먼저 수행!
    var c: Int = 12_4354_6538 // _ 언더 스코어를 통해서 숫자를 좀 더 알아보기 쉽게 표현한 것이며, 언더스코어의 위치와 개수는 마음대로 설정 가능.
    c = 0xFF_88_88 // 0x는 16진수 의미
    c = 0b01010010_01100011_01110101_01000101 // 0b는 2진수 의미  (참고로, 코틀린은 8진수 정수 리터럴을 지원 x)
    var d: Long = -543_7847_3984_7238_4723 // Int 범위를 초과하면 자동으로 Long 타입

    c = a + b // Byte 타입과 Short 타입을 더하면 Short 타입이 될 것 같지만 Int 타입이 됨. -> 더하기 뿐만아니라 어떤 산술 연산을 해도 Int 타입이 됨.
    d = c + 10L // 정수 리터럴 뒤에 L을 붙이면 Long 타입


    val e: Float = 0.1f
    val f: Double = 0.2
    val z = e + f

    // 결과로 0.3 이 출력될 것 같지만 0.30000000149011613 이 나오게 됨
    // 0.1과 0.2 의 이진 표현이 부동 소수점 형식으로 정확히 표현될 수 없기 때문.
    // 자세히 설명하자면 0.1f를 Double 형태로 변환 시 일부 정밀도가 손실이 된다. Double 타입에 가장 가까운 0.1f의 값은 0.10000000149011612이여서
    //0.10000000149011612 + 0.2 가 되어 0.30000000149011613 가 나오는 것.
    println(z)

}