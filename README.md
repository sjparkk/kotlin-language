# Kotlin 200제 Project

##

## Description
*** 
- 해당 프로젝트는 Kotlin Language 에 대해서 학습을 하기 위하여 '초보자를 위한 Kotlin 200제'를 읽고 정리한 프로젝트 입니다.

### Part1
***
- 코틀린 기초 문법 살펴보기 001 - 044
- 001 Hello, Kotlin!
- 002 표현식(Expression)
- 003 변수(Variable)
- 004 리터럴의 타입
- 005 산술 연산자(Arithmetic Operator) + - * / %
- 006 증감 연산자(Increment & Decrement Operator) + + - -
- 007 비트 연산자(Bitwise Operator) and or xor inv shl shr ushr
- 008 정수 타입과 실수 타입
- 009 실수 타입의 함정
- 010 문자 타입
- 011 문자열(String)
- 012 문자열 안에 표현식의 값을 집어넣기
- 013 타입 별명(Type Alias)
- 014 주석(Comment)
- 015 배정 연산자(Assignment Operator) =
- 016 문장(Statement)
- 017 비교 연산자(Comparison Operator) = = != 〉 〈 〉= 〈=
- 018 논리 연산자(Logical Operator) && || !
- 019 흐름 제어-조건문 if
- 020 흐름 제어-조건문 if- else
- 021 if와 else의 중첩
- 022 if-else를 표현식으로 사용하기
- 023 흐름 제어-조건문 when
- 024 when을 표현식으로 사용하기
- 025 흐름 제어-반복문 while
- 026 흐름 제어-반복문 do-while
- 027 흐름 제어 continue
- 028 흐름 제어 break
- 029 레이블(Label)
- 030 함수(Function)
- 031 매개변수(Parameter)와 인수(Argument)
- 032 Unit 타입
- 033 디폴트 인수
- 034 가변 인수
- 035 함수 오버로딩(Function Overloading)
- 036 지역 변수(Local Variable)와 전역 변수(Global Variable)
- 037 지역 변수와 전역 변수의 이름이 중복될 때
- 038 지역 변수와 다른 함수의 지역 변수가 중복될 때
- 039 지역 함수(Local Function)
- 040 메모리의 스택(Stack) 영역
- 041 소스 파일 여러 개로 분리하기
- 042 패키지(Package)
- 043 다른 패키지의 함수 호출하기
- 044 import

### Part2
***
- 코틀린 중급 문법 살펴보기 045 - 087
- 045 객체(Object)
- 046 메모리의 힙(Heap) 영역
- 047 클래스(Class)
- 048 힙 영역의 존재 이유
- 049 문자열간 + 연산 시 주의점
- 050 가비지 컬렉션(Garbage Collection)
- 051 = = =, != = 연산자
- 052 멤버 함수(Member Function)
- 053 프로퍼티와 멤버 함수의 매개변수 이름이 중복될 때
- 054 생성자(Constructor)와 초기화(Initializer) 블록
- 055 init 블록 나누어 쓰기
- 056 생성자와 프로퍼티 한번에 쓰기
- 057 보조 생성자(Secondary Constructor)
- 058 프로퍼티와 Getter/Setter
- 059 연산자 오버로딩(Operator Overloading)
- 060 번호 붙은 접근 연산자(Indexed Access Operator) [ ]
- 061 호출 연산자(Invoke Operator) ( )
- 062 in 연산자
- 063 멤버 함수의 중위 표기법(Infix Notation)
- 064 상속(Inheritance)
- 065 업캐스팅(Upcasting)
- 066 오버라이딩(Overriding)
- 067 프로퍼티를 오버라이딩하기
- 068 다형성(Polymorphism)의 활용
- 069 클래스를 상속하는 객체
- 070 Any 클래스
- 071 예외(Exception)
- 072 예외 처리
- 073 예외 던지기
- 074 Nothing 타입
- 075 Nullable 타입과 null
- 076 안전한 호출 연산자(Safe Call Operator) ?
- 077 Not-null 단정 연산자(Not-null Assertion Operator) !!
- 078 엘비스 연산자(Elvis Operator) ?:
- 079 스마트 캐스팅
- 080 is 연산자
- 081 as 연산자와 다운캐스팅
- 082 접근 지정자(Access Modifier)
- 083 접근 지정자: private
- 084 접근 지정자: protected
- 085 접근 지정자 오버라이딩
- 086 확장 함수(Extension Function)
- 087 확장 프로퍼티(Extension Property)

### Part3 (코틀린 고급 문법 살펴보기)
***
- 코틀린 고급 문법 살펴보기 088 - 127
- 088 객체 선언(Object Declaration)
- 089 동반자 객체(Companion Object)
- 090 inline 함수
- 091 const
- 092 lateinit
- 093 Nullable 리시버
- 094 동반자 객체의 확장 함수
- 095 확장 함수의 리시버 타입이 상속 관계에 있을 때
- 096 추상 클래스(Abstract Class)
- 097 인터페이스(Interface)
- 098 다이아몬드 문제(The Diamond Problem)
- 099 중첩 클래스(Nested Class)
- 100 내부 클래스(Inner Class)
- 101 데이터 클래스(Data Class)
- 102 객체 분해하기
- 103 함수 리터럴(Function Literal)과 람다식(Lambda Expression)
- 104 익명 함수(Anonymous Function)
- 105 it 식별자
- 106 함수 참조(Function Reference)
- 107 고차 함수(Higher-order Function)
- 108 클로저(Closure)
- 109 리시버가 붙은 함수 리터럴
- 110 제네릭(Generic)
- 111 여러 타입을 인수로 받기
- 112 구체화된(Reified) 타입 매개변수
- 113 클래스와 인터페이스에서 제네릭 사용하기
- 114 제네릭이 적용된 클래스/인터페이스 상속·구현하기
- 115 특정 타입을 상속·구현하는 타입만 인수로 받기
- 116 in/out 키워드
- 117 .. 연산자와 범위 표현식(Range Expression)
- 118 반복자(Iterator)
- 119 흐름 제어 - 반복문 for
- 120 배열(Array)
- 121 배열을 가변 인수로 활용하기
- 122 열거 클래스(Enum Class)
- 123 열거 클래스에 프로퍼티와 멤버 함수 선언하기
- 124 열거 클래스 활용하기
- 125 sealed 클래스
- 126 위임된 프로퍼티(Delegated Property)
- 127 클래스 위임(Class Delegation)

### Part4 (코틀린 표준 라이브러리 살펴보기)
***
- 코틀린 표준 라이브러리 살펴보기 128 - 189